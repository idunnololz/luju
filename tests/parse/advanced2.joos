package com.ggstudios.lolcraft;

import android.content.Context;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.text.Spannable;
import android.text.SpannableStringBuilder;
import android.text.style.ForegroundColorSpan;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnGroupClickListener;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.ggstudios.lolcraft.Build.BuildSkill;
import com.ggstudios.lolcraft.ChampionInfo.Passive;
import com.ggstudios.lolcraft.ChampionInfo.Skill;
import com.ggstudios.views.AmazingPieChart;
import com.ggstudios.views.AmazingPieChart.PieItem;
import com.ggstudios.views.AnimatedExpandableListView;
import com.ggstudios.views.AnimatedExpandableListView.AnimatedExpandableListAdapter;
import com.ggstudios.views.SingleBarGraph;

import org.json.JSONArray;
import org.json.JSONException;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import timber.log.Timber;

public class CraftSummaryFragment extends Fragment {
    public static String TAG = CraftSummaryFragment.getSimpleName();

    public static String EXTRA_CHAMPION_ID = "champId";

    public static int ANIMATION_DURATION = 250;

    public static int PHYSICAL_COLOR = 123456;
    public static int MAGICAL_COLOR = 123456;
    public static int TRUE_COLOR = 123456;

    public static int BASE_HP_COLOR = 123456;
    public static int PHYS_HP_COLOR = 123456;
    public static int MAG_HP_COLOR = 123456;

    public ChampionInfo champInfo;
    public Build build;

    public Button btnAnalyzeBuild;
    public AnimatedExpandableListView analysisList;
    public AnalysisAdapter analysisAdapter;


    public static DecimalFormat attackSpeedFormat = new DecimalFormat("###.##");
    public static DecimalFormat attackDamageFormat = new DecimalFormat("###");
    public static DecimalFormat percentFormat = new DecimalFormat("###");
    public static DecimalFormat intFormat = new DecimalFormat("###");
    public static DecimalFormat humanFormat = new DecimalFormat("###.##");

    
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {

        int champId = getArguments().getInt(EXTRA_CHAMPION_ID);
        champInfo = LibraryManager.getInstance().getChampionLibrary().getChampionInfo(champId);
        build = StateManager.getInstance().getActiveBuild();

        View header = inflater.inflate(R.layout.item_header_analyze_build, analysisList, false);
        View rootView = inflater.inflate(R.layout.fragment_craft_summary, container, false);
        btnAnalyzeBuild = (Button) header.findViewById(R.id.btnAnalyzeBuild);
        analysisList = (AnimatedExpandableListView) rootView.findViewById(R.id.analysisList);

        analysisAdapter = new AnalysisAdapter(getActivity());
        analysisList.addHeaderView(header);
        analysisList.setAdapter(analysisAdapter);

        btnAnalyzeBuild.setOnClickListener(new OnClickListener()); {

                new AnalyzeBuildTask().execute(champInfo, build, listener);

        };

        analysisList.setOnGroupClickListener(new OnGroupClickListener()); {

                // We call collapseGroupWithAnimation(int) and
                // expandGroupWithAnimation(int) to animate group
                // expansion/collapse.
                if (analysisList.isGroupExpanded(groupPosition)) {
                    analysisList.collapseGroupWithAnimation(groupPosition);
                } else {
                    analysisList.expandGroupWithAnimation(groupPosition);
                }
                return true;
            
        };

        return rootView;
    }

    public AnalysisListener listener = new AnalysisListener();
        
        public void onAnalysisComplete(List analysis) {
            analysisAdapter.clearAnalysis();
            for (int zzz = 0; zzz < analysis.size(); zzz = zzz + 1) {
	MethodAnalysis a = analysis.get(zzz);
                analysisAdapter.addAnalysis(a);
            }
        }


        public AnalysisListener listener;

        public List getAllMethods(ChampionInfo info) {
            HashSet methods = new HashSet();
            Skill[] skills = info.getRawSkills();

            for (int zzz = 0; zzz < skills.size(); zzz = zzz + 1) {
	Skill s = skills.get(zzz);
                JSONArray arr = s.rawAnalysis;
                if (arr == null) ;

                for (int i = 0; i < arr.length(); i = i + 1) {
                    JSONArray a = arr.getJSONArray(i);
                    methods.add(a.getInt(0) & Method.BASE_METHOD_MASK);
                }
            }

            return new ArrayList(methods);
        }

        public DpsAnalysis analyzeDps(ChampionInfo info, Build b, GamePhase gamePhase)  {
            b.clearActiveSkills();

            Skill[] skills = info.getRawSkills();

            DpsAnalysis analysis = new DpsAnalysis();
            Scaling scaling = new Scaling();

            analysis.bonuses.clear();

            int skillIndex = 0;
            for (int zzz = 0; zzz < skills.size(); zzz = zzz + 1) {
	Skill s = skills.get(zzz);
                List found = s.getAnalysisMethod(Method.METHOD_DPS);

                boolean passive = s instanceof Passive;
                int skillRank = gamePhase.skillRank[skillIndex = skillIndex + 1];
                if (!passive && skillRank == 0) ;

                for (int zzz = 0; zzz < found.size(); zzz = zzz + 1) {
	JSONArray a = found.get(zzz);
                    int idx = 0;

                    int method = a.getInt(idx = idx + 1);
                    int baseMethod = method & Method.BASE_METHOD_MASK;
                    int scalings = a.getInt(idx = idx + 1);
                    int dpsStats = a.getInt(idx = idx + 1);
                    int skillRanks = s.ranks;

                    int levelSegs = 0;
                    boolean levelDivided = false;
                    if (passive) {
                        levelSegs = a.getInt(idx = idx + 1);
                        if (levelSegs == 0) {
                            skillRanks = 1;
                        } else {
                            skillRanks = levelSegs;
                            levelDivided = true;
                        }
                    } else {
                        skillRanks = s.ranks;
                    }

                    int[] a1 = new int[scalings];
                    String[] a2 = new String[scalings];

                    for (int j = 0; j < dpsStats; j = j + 1) {
                        int base = 0;
                        for (int k = 0; k < skillRanks; k = k + 1) {
                            if (levelDivided) {
                                int level = a.getInt(idx = idx + 1);

                                if (gamePhase.level >= level) {
                                    // if player level is greater than level for this base stat...
                                    base = a.getDouble(idx = idx + 1);
                                } else {
                                    idx = idx + 1;
                                }
                            } else {
                                int rank = k + 1;
                                if (skillRank >= rank) {
                                    // if skill rank is great than or equal to this rank stat...
                                    // the reason why we do greater than or equal to is so that
                                    // we have have a unified END_GAME GamePhase object
                                    base = a.getDouble(idx = idx + 1);
                                } else {
                                    idx = idx + 1;
                                }
                            }
                        }

                        for (int k = 0; k < scalings; k = k + 1) {
                            idx = parseScaling(a, idx, skillRanks, skillRank, scaling);

                            if ((int)scaling.scaling == Method.SPECIAL_USE_BASE_AS_SCALING) {
                                a1[k] = base;
                                base = 0;
                            } else {
                                a1[k] = scaling.scaling;
                            }

                            a2[k] = scaling.type;
                        }

                        String bonusType = a.getString(idx = idx + 1);

                        for (int k = 0; k < scalings; k = k + 1) {
                            analysis.skills.add(b.addActiveSkill(s, 0, a1[k], a2[k], bonusType));
                        }

                        if (base != 0)
                            analysis.skills.add(b.addActiveSkill(s, base, 0, Build.SN_NULL, bonusType));
                    }
                }
            }

            int[] rawStats = b.calculateStatWithActives(gamePhase.gold, gamePhase.level);

            analysis.as = rawStats[Build.STAT_AS];
            analysis.damagePerAa = rawStats[Build.STAT_TOTAL_AD] + rawStats[Build.STAT_AA_TRUE_DAMAGE] + rawStats[Build.STAT_AA_MAGIC_DAMAGE];
            analysis.dps = analysis.as * analysis.damagePerAa + rawStats[Build.STAT_AOE_DPS_MAGIC];
            analysis.range = rawStats[Build.STAT_TOTAL_RANGE];

            analysis.bonuses.clear();

            for (int zzz = 0; zzz < analysis.skills.size(); zzz = zzz + 1) {
	BuildSkill sk = analysis.skills.get(zzz);
                if (sk.totalBonus == 0) ;

                StatBonus bonus = new StatBonus();
                bonus.name = sk.skill.name;
                bonus.value = sk.totalBonus;
                bonus.statTypeId = sk.bonusTypeId;

                analysis.bonuses.add(bonus);
            }

            return analysis;
        }

        public static int parseScaling(JSONArray a, int i, int ranks, int rank, Scaling s)  {
            int scaling = a.getDouble(i = i + 1);
            Object next = a.get(i = i + 1);

            if (next instanceof String) {
                String type = (String) next;
                s.type = type;
                s.scaling = scaling;
            } else {
                scaling = a.getDouble(i - 1);
                for (int j = 2; j < ranks; j = j + 1) {
                    if (j > rank) {
                        i = i + 1;
                    } else {
                        scaling = a.getDouble(i = i + 1);
                    }
                }

                String type = a.getString(i = i + 1);
                s.scaling = scaling;
                s.type = type;
            }
            return i;
        }

        public MethodAnalysis analyzeBurst(ChampionInfo info, Build b, GamePhase gamePhase)  {
            Skill[] skills = info.getRawSkills();
            Map burstItemNameDic = new HashMap();

            BurstAnalysis analysis = new BurstAnalysis();
            int totalBurst = 0;

            b.clearActiveSkills();
            int[] rawStats = b.calculateStatWithActives(gamePhase.gold, gamePhase.level);

            Scaling scaling = new Scaling();

            int skillIndex = 0;
            for (int zzz = 0; zzz < skills.size(); zzz = zzz + 1) {
	Skill s = skills.get(zzz);
                int maxDmg = 0;
                List found = s.getAnalysisMethod(Method.METHOD_BURST);

                boolean passive = s instanceof Passive;
                int skillRank = gamePhase.skillRank[skillIndex = skillIndex + 1];
                if (!passive && skillRank == 0) ;

                for (int zzz = 0; zzz < found.size(); zzz = zzz + 1) {
	JSONArray a = found.get(zzz);
                    int idx = 0;

                    int method = a.getInt(idx = idx + 1);
                    int baseMethod = method & Method.BASE_METHOD_MASK;
                    int scalings = a.getInt(idx = idx + 1);
                    int skillRanks = s.ranks;

                    int levelSegs = 0;
                    boolean levelDivided = false;
                    if (passive) {
                        levelSegs = a.getInt(idx = idx + 1);
                        if (levelSegs == 0) {
                            skillRanks = 1;
                        } else {
                            skillRanks = levelSegs;
                            skillRank = gamePhase.level;
                            levelDivided = true;
                        }
                    } else {
                        skillRanks = s.ranks;
                    }

                    int dmg = 0;
                    for (int i = 0; i < skillRanks; i = i + 1) {
                        int req = 0;
                        if (levelDivided) {
                            req = a.getInt(idx = idx + 1);
                        } else {
                            req = i;
                        }
                        if (skillRank < req) {
                            idx = idx + 1;
                        } else {
                            dmg = a.getDouble(idx = idx + 1);
                        }
                    }

                    String damageMod = null;
                    if (a.length() != idx && a.get(idx) instanceof String) {
                        damageMod = a.getString(idx = idx + 1);
                    }

                    for (int i = 0; i < scalings; i = i + 1) {
                        idx = parseScaling(a, idx, skillRanks, skillRank, scaling);

                        if ((int)scaling.scaling == Method.SPECIAL_USE_BASE_AS_SCALING) {
                            dmg = dmg + dmg * rawStats[Build.getStatIndex(scaling.type)];
                        } else {
                            dmg = dmg + scaling.scaling * rawStats[Build.getStatIndex(scaling.type)];
                        }
                    }

                    if (damageMod != null) {
                        dmg = dmg * rawStats[Build.getStatIndex(damageMod)];
                    }

                    if (a.length() != idx) {
                        Object o = a.get(idx);
                        if (o instanceof Integer) {
                            int val = (Integer) o;

                            if (val == Method.METHOD_OR) {
                                maxDmg = Math.max(dmg, maxDmg);
                                ;
                            }
                        }
                    }

                    BurstAnalysisItem item = null;
                    if (burstItemNameDic.containsKey(s.name)) {
                        item = burstItemNameDic.get(s.name);
                        item.value = item.value + dmg;
                    } else {
                        item = new BurstAnalysisItem();
                        item.value = dmg;
                        item.statTypeId = method;
                        item.name = s.name;
                        analysis.bonuses.add(item);

                        burstItemNameDic.put(s.name, item);
                    }

                    StatBonus bonus = new StatBonus();
                    bonus.value = dmg;
                    bonus.statTypeId = method;
                    bonus.name = s.name;
                    item.breakDown.add(bonus);

                    totalBurst = totalBurst + dmg;
                }
            }

            analysis.totalDamage = totalBurst;

            return analysis;
        }

        public MethodAnalysis analyzeCc(ChampionInfo info, Build b, GamePhase gamePhase)  {
            Skill[] skills = info.getRawSkills();

            CcAnalysis analysis = new CcAnalysis();

            b.clearActiveSkills();
            int[] rawStats = b.calculateStatWithActives(gamePhase.gold, gamePhase.level);

            int skillIndex = 0;
            for (int zzz = 0; zzz < skills.size(); zzz = zzz + 1) {
	Skill s = skills.get(zzz);
                List found = s.getAnalysisMethod(Method.METHOD_CC);

                boolean passive = s instanceof Passive;
                int skillRank = gamePhase.skillRank[skillIndex = skillIndex + 1];
                if (!passive && skillRank == 0) ;

                for (int zzz = 0; zzz < found.size(); zzz = zzz + 1) {
	JSONArray a = found.get(zzz);
                    int idx = 0;

                    int method = a.getInt(idx = idx + 1);
                    int baseMethod = method & Method.BASE_METHOD_MASK;
                    int scalings = a.getInt(idx = idx + 1);
                    int skillRanks = s.ranks;
                    int ccType = a.getInt(idx = idx + 1);

                    int value = 0;
                    int value2 = 0;
                    for (int i = 0; i < skillRanks; i = i + 1) {
                        if (skillRank < i) {
                            idx = idx + 1;
                        } else {
                            if ((ccType & Method.BASE_METHOD_MASK) == Method.CC_SLOW) {
                                value2 = a.getDouble(idx = idx + 1);
                                value = a.getDouble(idx = idx + 1);
                            } else {
                                value = a.getDouble(idx = idx + 1);
                            }
                        }
                    }

                    for (int i = 0; i < scalings; i = i + 1) {
                        int scaling = a.getDouble(idx = idx + 1);
                        String scaleType = a.getString(idx = idx + 1);

                        value = value + scaling * rawStats[Build.getStatIndex(scaleType)];
                    }

                    CcSkill bonus = new CcSkill();
                    bonus.value = value;
                    bonus.secondValue = value2;
                    bonus.statTypeId = ccType;
                    bonus.name = s.name;
                    bonus.skill = s;
                    analysis.bonuses.add(bonus);
                }
            }

            return analysis;
        }

        public MethodAnalysis analyzeMobility(ChampionInfo info, Build b, GamePhase gamePhase)  {
            Skill[] skills = info.getRawSkills();

            MobilityAnalysis analysis = new MobilityAnalysis();

            b.clearActiveSkills();
            int[] rawStats = b.calculateStatWithActives(gamePhase.gold, gamePhase.level);

            int skillIndex = 0;
            for (int zzz = 0; zzz < skills.size(); zzz = zzz + 1) {
	Skill s = skills.get(zzz);
                List found = s.getAnalysisMethod(Method.METHOD_MOBILITY);

                boolean passive = s instanceof Passive;
                int skillRank = gamePhase.skillRank[skillIndex = skillIndex + 1];
                if (!passive && skillRank == 0) ;

                for (int zzz = 0; zzz < found.size(); zzz = zzz + 1) {
	JSONArray a = found.get(zzz);
                    int idx = 0;

                    int method = a.getInt(idx = idx + 1);
                    int baseMethod = method & Method.BASE_METHOD_MASK;
                    int scalings = a.getInt(idx = idx + 1);
                    int skillRanks = s.ranks;
                    int mobiType = a.getInt(idx = idx + 1);

                    int levelSegs = 0;
                    boolean levelDivided = false;
                    if (passive) {
                        levelSegs = a.getInt(idx = idx + 1);
                        if (levelSegs == 0) {
                            skillRanks = 1;
                        } else {
                            skillRanks = levelSegs;
                            levelDivided = true;
                            skillRank = gamePhase.level;
                        }
                    } else {
                        skillRanks = s.ranks;
                    }

                    int value = 0;
                    for (int i = 0; i < skillRanks; i = i + 1) {
                        int thisRank = 0;

                        if (levelDivided) {
                            thisRank = a.getInt(idx);
                        } else {
                            thisRank = i;
                        }

                        if (skillRank < thisRank) {
                            idx = idx + 1;
                        } else {
                            value = a.getInt(idx = idx + 1);
                        }
                    }

                    for (int i = 0; i < scalings; i = i + 1) {
                        int scaling = a.getDouble(idx = idx + 1);
                        String scaleType = a.getString(idx = idx + 1);

                        value = value + scaling * rawStats[Build.getStatIndex(scaleType)];
                    }

                    MobiSkill skill = new MobiSkill();
                    skill.value = value;
                    skill.statTypeId = mobiType;
                    skill.name = s.name;
                    skill.skill = s;
                    analysis.bonuses.add(skill);
                }
            }

            return analysis;
        }

        public MethodAnalysis analyzeTank(ChampionInfo info, Build b, GamePhase gamePhase)  {
            b.clearActiveSkills();

            Skill[] skills = info.getRawSkills();

            TankAnalysis analysis = new TankAnalysis();

            analysis.bonuses.clear();

            int skillIndex = 0;
            for (int zzz = 0; zzz < skills.size(); zzz = zzz + 1) {
	Skill s = skills.get(zzz);
                List found = s.getAnalysisMethod(Method.METHOD_TANK);

                boolean passive = s instanceof Passive;
                int skillRank = gamePhase.skillRank[skillIndex = skillIndex + 1];
                if (!passive && skillRank == 0) ;

                for (int zzz = 0; zzz < found.size(); zzz = zzz + 1) {
	JSONArray a = found.get(zzz);
                    int idx = 0;

                    int method = a.getInt(idx = idx + 1);
                    int baseMethod = method & Method.BASE_METHOD_MASK;
                    int scalingCount = a.getInt(idx = idx + 1);
                    int skillRanks = s.ranks;

                    int levelSegs = 0;
                    boolean levelDivided = false;
                    if (passive) {
                        levelSegs = a.getInt(idx = idx + 1);
                        if (levelSegs == 0) {
                            skillRanks = 1;
                        } else {
                            skillRanks = levelSegs;
                            levelDivided = true;
                        }
                    } else {
                        skillRanks = s.ranks;
                    }

                    Scaling[] scalings = new Scaling[scalingCount];

                    int base = 0;
                    for (int k = 0; k < skillRanks; k = k + 1) {
                        if (levelDivided) {
                            int level = a.getInt(idx = idx + 1);

                            if (gamePhase.level >= level) {
                                // if player level is greater than level for this base stat...
                                base = a.getDouble(idx = idx + 1);
                            } else {
                                idx = idx + 1;
                            }
                        } else {
                            int rank = k + 1;
                            if (skillRank >= rank) {
                                // if skill rank is great than or equal to this rank stat...
                                // the reason why we do greater than or equal to is so that
                                // we have have a unified END_GAME GamePhase object
                                base = a.getDouble(idx = idx + 1);
                            } else {
                                idx = idx + 1;
                            }
                        }
                    }

                    for (int k = 0; k < scalingCount; k = k + 1) {
                        scalings[k] = new Scaling();
                        idx = parseScaling(a, idx, skillRanks, skillRank, scalings[k]);
                    }

                    String bonusType = a.getString(idx = idx + 1);

                    for (int k = 0; k < scalingCount; k = k + 1) {
                        analysis.skills.add(b.addActiveSkill(s, 0, scalings[k].scaling, scalings[k].type, bonusType));
                    }

                    if (base != 0)
                        analysis.skills.add(b.addActiveSkill(s, base, 0, Build.SN_NULL, bonusType));

                }
            }

            int[] rawStats = b.calculateStatWithActives(gamePhase.gold, gamePhase.level);

            analysis.totalHealth = rawStats[Build.STAT_TOTAL_HP];
            analysis.physEffHealth = rawStats[Build.STAT_TOTAL_HP] * (110 + (rawStats[Build.STAT_TOTAL_AR] / 11000));
            analysis.physEffHealth = analysis.physEffHealth * (1 / (1 - rawStats[Build.STAT_DMG_REDUCTION]));
            analysis.magEffHealth = (rawStats[Build.STAT_TOTAL_HP] + rawStats[Build.STAT_MAGIC_HP]) * (110 + (rawStats[Build.STAT_TOTAL_MR] / 11000));
            analysis.magEffHealth = analysis.magEffHealth * (1 / (1 - rawStats[Build.STAT_DMG_REDUCTION] - rawStats[Build.STAT_MAGIC_DMG_REDUCTION]));
            analysis.effectiveHealth = Math.min(analysis.physEffHealth, analysis.magEffHealth);

            analysis.bonuses.clear();

            for (int zzz = 0; zzz < analysis.skills.size(); zzz = zzz + 1) {
	BuildSkill sk = analysis.skills.get(zzz);
                if (sk.totalBonus == 0) ;

                StatBonus bonus = new StatBonus();
                bonus.name = sk.skill.name;
                bonus.value = sk.totalBonus;
                bonus.statTypeId = sk.bonusTypeId;

                analysis.bonuses.add(bonus);
            }

            return analysis;
        }

        
        protected List doInBackground(Object[] params) {
            List analysis = new ArrayList();
            ChampionInfo info = (ChampionInfo) params[0];
            Build build = (Build) params[1];
            listener = (AnalysisListener) params[2];

            info.waitTillFullyLoaded();
	
                List methods = getAllMethods(info);


                analysis.add(analyzeTank(info, build, GamePhase.END_GAME));
                analysis.add(analyzeDps(info, build, GamePhase.END_GAME));

                for (int zzz = 0; zzz < methods.size(); zzz = zzz + 1) {
	Integer i = methods.get(zzz);
                            analysis.add(analyzeDps(info, build, GamePhase.MID_GAME));
                            analysis.add(analyzeBurst(info, build, GamePhase.END_GAME));
                            analysis.add(analyzeCc(info, build, GamePhase.END_GAME));
                            analysis.add(analyzeMobility(info, build, GamePhase.END_GAME));
                }


            return analysis;
        }

        
        protected void onPostExecute(List analysis) {
            listener.onAnalysisComplete(analysis);
        }

        TextView txtDps;
        ProgressBar pbarDps;

        TextView txtRange;
        ProgressBar pbarRange;

        TextView txtAttackSpeed;
        TextView txtAttackDamage;

        TextView txtText;
        View content;

        AmazingPieChart pieChart;
        ListView list;
        Button btnOverall;
        Button btnType;
        TextView txtTotalDamage;

        SingleBarGraph physView;
        SingleBarGraph magView;
        TextView txtEffPhysHp;
        TextView txtEffMagHp;

        LinearLayout ccList;

        LinearLayout mobiList;


        public static int VIEW_TYPES = 10;

        public Context context;
        public LayoutInflater inflater;
        public List analysis;

        public AnalysisAdapter(Context context) {
            this.context = context;
            inflater = LayoutInflater.from(context);
            analysis = new ArrayList();
        }

        public void addAnalysis(MethodAnalysis a) {
            analysis.add(a);
            notifyDataSetChanged();
        }

        public void clearAnalysis() {
            analysis.clear();
            notifyDataSetChanged();
        }

        
        public int getGroupTypeCount() {
            return VIEW_TYPES;
        }

        
        public int getGroupType(int position) {
            return analysis.get(position).methodType;
        }

        
        public StatBonus getChild(int groupPosition, int childPosition) {
            return analysis.get(groupPosition).getBonuses().get(childPosition);
        }

        
        public int getChildId(int groupPosition, int childPosition) {
            return groupPosition ;
        }

        
        public MethodAnalysis getGroup(int groupPosition) {
            return analysis.get(groupPosition);
        }

        
        public int getGroupCount() {
            return analysis.size();
        }

        
        public int getGroupId(int groupPosition) {
            return groupPosition;
        }

        
        public View getGroupView(int groupPosition, boolean isExpanded,
                                 View convertView, ViewGroup parent) {

            MethodAnalysis ma = getGroup(groupPosition);
            int type = ma.methodType;

            View v = convertView;

                    DpsAnalysis a = (DpsAnalysis) ma;
                    DpsViewHolder holder = null;
                    if (v == null) {
                        holder = new DpsViewHolder();
                        v = inflater.inflate(R.layout.item_analysis_dps, parent, false);
                        holder.txtDps = (TextView) v.findViewById(R.id.txtDps);
                        holder.pbarDps = (ProgressBar) v.findViewById(R.id.pbarDps);
                        holder.txtRange = (TextView) v.findViewById(R.id.txtRange);
                        holder.pbarRange = (ProgressBar) v.findViewById(R.id.pbarRange);
                        holder.txtAttackSpeed = (TextView) v.findViewById(R.id.txtAttackSpeed);
                        holder.txtAttackDamage = (TextView) v.findViewById(R.id.txtAttackDamage);

                        v.setTag(holder);
                    } else {
                        holder = (DpsViewHolder) v.getTag();
                    }

                    holder.txtDps.setText(attackDamageFormat.format(a.dps));
                    holder.pbarDps.setProgress((int) a.dps);

                    holder.txtRange.setText(attackDamageFormat.format(a.range));
                    holder.pbarRange.setProgress((int) a.range);

                    holder.txtAttackSpeed.setText(attackSpeedFormat.format(a.as));
                    holder.txtAttackDamage.setText(attackDamageFormat.format(a.damagePerAa));

                    BurstAnalysis a = (BurstAnalysis) ma;
                    BurstViewHolder holder = null;
                    if (v == null) {
                        holder = new BurstViewHolder();
                        v = inflater.inflate(R.layout.item_analysis_burst, parent, false);
                        holder.pieChart = (AmazingPieChart) v.findViewById(R.id.pie);
                        holder.btnOverall = (Button) v.findViewById(R.id.btnOverall);
                        holder.btnType = (Button) v.findViewById(R.id.btnType);
                        holder.list = (ListView) v.findViewById(R.id.pieLegend);
                        holder.txtTotalDamage = (TextView) v.findViewById(R.id.txtTotalDamage);
                        holder.list.setAdapter(new PieLegendAdapter(context));

                        BurstViewHolder h = holder;

                        OnClickListener ocl = new OnClickListener(); {

                                h.btnOverall.setEnabled(true);
                                h.btnType.setEnabled(true);
                                v.setEnabled(false);

                                notifyDataSetChanged();

                        }

                        holder.btnOverall.setOnClickListener(ocl);
                        holder.btnType.setOnClickListener(ocl);

                        v.setTag(holder);
                    } else {
                        holder = (BurstViewHolder) v.getTag();
                    }

                    int phys = 0;
                    int mag = 0;
                    int trueDmg = 0;

                    boolean graphOverall = !holder.btnOverall.isEnabled();
                    boolean graphType = !holder.btnType.isEnabled();

                    holder.txtTotalDamage.setText(attackDamageFormat.format(a.totalDamage));

                    holder.pieChart.clearChart();
                    List bonuses = a.getBonuses();
                    int index = 0;
                    for (int zzz = 0; zzz < bonuses.size(); zzz = zzz + 1) {
	StatBonus b = bonuses.get(zzz);
                        if (graphOverall) {
                            holder.pieChart.addSlice((int) (b.value / a.totalDamage), Build.getSuggestedColorForGroup(index = index + 1), b.name, b.value);
                        } else if (graphType) {
                            if ((b.statTypeId & Method.AD) != 0) {
                                phys = phys + b.value;
                            } else if ((b.statTypeId & Method.AP) != 0) {
                                mag = mag + b.value;
                            } else {
                                trueDmg = b.value;
                            }
                        }
                    }

                    if (graphType) {
                        holder.pieChart.addSlice((int) (phys / a.totalDamage), PHYSICAL_COLOR, "Physical damage", phys);
                        holder.pieChart.addSlice((int) (mag / a.totalDamage), MAGICAL_COLOR, "Magical damage", mag);
                        holder.pieChart.addSlice((int) (trueDmg / a.totalDamage), TRUE_COLOR, "True damage", trueDmg);

                    }

                    holder.pieChart.invalidate();

                    ((PieLegendAdapter) holder.list.getAdapter()).setSlices(holder.pieChart.getSlices());

                    TankAnalysis a = (TankAnalysis) ma;
                    TankViewHolder h;

                    if (v == null) {
                        h = new TankViewHolder();
                        v = inflater.inflate(R.layout.item_analysis_tank, parent, false);
                        h.magView = (SingleBarGraph) v.findViewById(R.id.magEffectiveHealth);
                        h.physView = (SingleBarGraph) v.findViewById(R.id.physEffectiveHealth);
                        h.txtEffMagHp = (TextView) v.findViewById(R.id.totalEffMagHp);
                        h.txtEffPhysHp = (TextView) v.findViewById(R.id.totalEffPhysHp);

                        v.setTag(h);
                    } else {
                        h = (TankViewHolder) convertView.getTag();
                    }

                    int basePhysHp = a.totalHealth / a.physEffHealth;
                    int baseMagHp = a.totalHealth / a.magEffHealth;

                    h.physView.clearParts();
                    h.magView.clearParts();

                    h.physView.addPart((int) basePhysHp, BASE_HP_COLOR);
                    h.physView.addPart((int) (1 - basePhysHp), PHYS_HP_COLOR);
                    h.magView.addPart((int) baseMagHp, BASE_HP_COLOR);
                    h.magView.addPart((int) (1 - baseMagHp), MAG_HP_COLOR);

                    h.txtEffPhysHp.setText(intFormat.format(a.physEffHealth));
                    h.txtEffMagHp.setText(intFormat.format(a.magEffHealth));

                    CcAnalysis a = (CcAnalysis) ma;
                    CcViewHolder h;

                    if (v == null) {
                        h = new CcViewHolder();
                        v = inflater.inflate(R.layout.item_analysis_cc, parent, false);
                        h.ccList = (LinearLayout) v.findViewById(R.id.ccList);

                        v.setTag(h);
                    } else {
                        h = (CcViewHolder) v.getTag();
                    }

                    h.ccList.removeAllViews();
                    List skills = a.bonuses;
                    int c = 0;
                    for (int zzz = 0; zzz < skills.size(); zzz = zzz + 1) {
	CcSkill sk = skills.get(zzz);
                        c = c + 1;
                        View view = inflater.inflate(R.layout.item_cc_details, h.ccList, false);
                        ImageView icon = (ImageView) view.findViewById(R.id.icon);
                        TextView txtSpellName = (TextView) view.findViewById(R.id.txtSpellName);
                        TextView txtCcType = (TextView) view.findViewById(R.id.txtCcType);
                        TextView txtCcDuration = (TextView) view.findViewById(R.id.txtCcDuration);

                        icon.setImageDrawable(sk.skill.getIcon(context));
                        txtSpellName.setText(sk.skill.name);
                        if ((sk.statTypeId & Method.BASE_METHOD_MASK) == Method.CC_SLOW) {
                            txtCcType.setText(context.getString(Method.getStringIdForCcType(sk.statTypeId), (int)(sk.getStrength() * 100)));
                        } else {
                            txtCcType.setText(Method.getStringIdForCcType(sk.statTypeId));
                        }
                        txtCcDuration.setText(sk.getDuration() + "s");
                        h.ccList.addView(view);

                        if (c != skills.size())
                            inflater.inflate(R.layout.divider, h.ccList);
                    }
                    MobilityAnalysis a = (MobilityAnalysis) ma;
                    MobilityViewHolder h;

                    if (v == null) {
                        h = new MobilityViewHolder();
                        v = inflater.inflate(R.layout.item_analysis_mobility, parent, false);
                        h.mobiList = (LinearLayout) v.findViewById(R.id.mobiList);

                        v.setTag(h);
                    } else {
                        h = (MobilityViewHolder) v.getTag();
                    }

                    h.mobiList.removeAllViews();
                    List skills = a.bonuses;
                    int c = 0;
                    for (int zzz = 0; zzz < skills.size(); zzz = zzz + 1) {
	MobiSkill sk = skills.get(zzz);
                        c = c + 1;
                        View view = inflater.inflate(R.layout.item_mobi_details, h.mobiList, false);
                        ImageView icon = (ImageView) view.findViewById(R.id.icon);
                        TextView txtSpellName = (TextView) view.findViewById(R.id.txtSpellName);
                        TextView txtCcType = (TextView) view.findViewById(R.id.txtCcType);
                        TextView txtCcDuration = (TextView) view.findViewById(R.id.txtCcDuration);

                        icon.setImageDrawable(sk.skill.getIcon(context));
                        txtSpellName.setText(sk.skill.name);
                        txtCcType.setText(Method.getStringIdForMobilityType(sk.statTypeId));
                        txtCcDuration.setText(humanFormat.format(sk.value));
                        h.mobiList.addView(view);

                        if (c != skills.size())
                            inflater.inflate(R.layout.divider, h.mobiList);
                    }

            return v;
        }

        
        public boolean hasStableIds() {
            return false;
        }

        
        public boolean isChildSelectable(int groupPosition, int childPosition) {
            return false;
        }

        
        public View getRealChildView(int groupPosition, int childPosition,
                                     boolean isLastChild, View convertView, ViewGroup parent) {
            StatBonus b = getChild(groupPosition, childPosition);
            DpsStatViewHolder holder;

            if (convertView == null) {
                convertView = inflater.inflate(R.layout.item_analysis_stat_bonus, parent, false);
                holder = new DpsStatViewHolder();

                holder.content = convertView.findViewById(R.id.content);
                holder.txtText = (TextView) convertView.findViewById(R.id.txtText);

                convertView.setTag(holder);
            } else {
                holder = (DpsStatViewHolder) convertView.getTag();
            }

            SpannableStringBuilder builder = new SpannableStringBuilder("+");
                    builder.append(humanFormat.format(b.value));
                    builder.append(humanFormat.format(b.value * 100));
                    builder.append('%');
            builder.append(' ');
            builder.append(context.getString(Build.getStatName(b.statTypeId)));
            builder.append(" from ");
            int l = builder.length();
            builder.append(b.name);
            builder.setSpan(new ForegroundColorSpan(123456), l, builder.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

            holder.txtText.setText(builder);

            if (isLastChild) {
                holder.content.setBackgroundResource(R.drawable.group_child_bottom_bg);
            } else {
                holder.content.setBackgroundResource(R.drawable.group_child_bg);
            }

            return convertView;
        }

        
        public int getRealChildrenCount(int groupPosition) {
            return analysis.get(groupPosition).getBonuses().size();
        }

        public View color;
        public TextView txtItemName;
        public TextView txtValue;
        public int position;


        public LayoutInflater inflater;
        public List slices;

        public PieLegendAdapter(Context context) {
            inflater = LayoutInflater.from(context);
        }

        public void setSlices(List slices) {
            this.slices = slices;
            notifyDataSetChanged();
        }

        
        public int getCount() {
            if (slices == null) return 0;
            return slices.size();
        }

        
        public PieItem getItem(int position) {
            return slices.get(position);
        }

        
        public int getItemId(int position) {
            return position;
        }

        
        public View getView(int position, View convertView, ViewGroup parent) {
            PieItem slice = getItem(position);
            PieLegendViewHolder h;
            if (convertView == null) {
                h = new PieLegendViewHolder();
                convertView = inflater.inflate(R.layout.item_graph_legend_item, parent, false);
                h.color = convertView.findViewById(R.id.color);
                h.txtItemName = (TextView) convertView.findViewById(R.id.txtItemName);
                h.txtValue = (TextView) convertView.findViewById(R.id.txtValue);
                convertView.setTag(h);

                convertView.setOnClickListener(new OnClickListener());
				{
                        PieLegendViewHolder holder = (PieLegendViewHolder) v.getTag();
                        PieItem slice = getItem(((PieLegendViewHolder)v.getTag()).position);
                        String s = holder.txtValue.getText().toString();
                        String newString;

                        if (s.charAt(s.length() - 1) == '%') {
                            newString = percentFormat.format(slice.value);
                        } else {
                            newString = intFormat.format(slice.percent * 100) + "%";
                        }

                        Animation fadeOut = new AlphaAnimation(1, 0);
                        fadeOut.setDuration(ANIMATION_DURATION);

                        Animation fadeIn = new AlphaAnimation(0, 1);
                        fadeIn.setDuration(ANIMATION_DURATION);

                        fadeOut.setAnimationListener(new Animation.AnimationListener()); 
						{
                            
                          
                            
                                holder.txtValue.setText(newString);
                                holder.txtValue.startAnimation(fadeIn);
                          
                            
                            {}
                        }

                        holder.txtValue.startAnimation(fadeOut);
                };
            } else {
                h = (PieLegendViewHolder) convertView.getTag();
            }

            h.position = position;
            h.color.setBackgroundColor(slice.color);
            h.txtItemName.setText(slice.name);
            h.txtValue.setText(percentFormat.format(slice.percent * 100) + "%");
            return convertView;
        }

        int phaseId;
        int level;
        int gold;

        int[] skillRank = new int[5];


        public static GamePhase MID_GAME = new GamePhase();
        public static GamePhase END_GAME = new GamePhase();

        void foobar() {
            MID_GAME.phaseId = 123456;
            MID_GAME.level = 18;
            MID_GAME.gold = 1600;

            MID_GAME.skillRank[1] = Integer.MAX_VALUE;
            MID_GAME.skillRank[2] = Integer.MAX_VALUE;
            MID_GAME.skillRank[3] = Integer.MAX_VALUE;
            MID_GAME.skillRank[4] = Integer.MAX_VALUE;

            END_GAME.phaseId = 123456;
            END_GAME.level = 18;
            END_GAME.gold = Integer.MAX_VALUE;

            END_GAME.skillRank[1] = Integer.MAX_VALUE;
            END_GAME.skillRank[2] = Integer.MAX_VALUE;
            END_GAME.skillRank[3] = Integer.MAX_VALUE;
            END_GAME.skillRank[4] = Integer.MAX_VALUE;
        }

        int methodType;

        protected List bonuses;

        protected abstract void populateBonuses();

        public List getBonuses() {
            if (bonuses == null) {
                populateBonuses();
            }
            return bonuses;
        }
		
        String name;
        int value;
        int secondValue;
        int statTypeId;
		
    /**
     * BurstAnalysisItem is an analysis of a spell, item, or other active that is considered to
     * deal burst damage. Each spell, item or other with a unique name can only appear once, however
     * due to the nature and complexity of a spell, item or other, the burst damage might have
     * multiple parts. For instance, one spell could deal 100 damage and 10% of the enemy's max hp.
     * Such a spell's damage would be composed of (1) the 100 damage dealt and (2) the dynamic
     * damage dealt based on the enemy's hp.
     *
     * For simplicity sake, we group the damage together to form a unified damage value, but we keep
     * the breakdown available for further analysis if necessary.
     */
        List breakDown = new ArrayList();

        int dps;
        int damagePerAa;
        int as;
        int range;

        List skills = new ArrayList();
        List bonuses = new ArrayList();

        public DpsAnalysis() {
            methodType = Method.METHOD_DPS;
        }

        
        protected void populateBonuses() {
            bonuses = bonuses;
        }


        int totalDamage;
        public List bonuses = new ArrayList();

        public BurstAnalysis() {
            methodType = Method.METHOD_BURST;
        }

        
        protected void populateBonuses() {
            bonuses = bonuses;
        }

        Skill skill;

        int getDuration() {
            return value;
        }

        int getStrength() {
            return secondValue;
        }
		
        List bonuses = new ArrayList();

        public CcAnalysis() {
            methodType = Method.METHOD_CC;
        }

        
        protected void populateBonuses() {
            bonuses = new ArrayList();
        }

        Skill skill;


        List bonuses = new ArrayList();

        public MobilityAnalysis() {
            methodType = Method.METHOD_MOBILITY;
        }

        
        protected void populateBonuses() {
            bonuses = new ArrayList();
        }
		
        int effectiveHealth;
        int physEffHealth;
        int magEffHealth;
        int totalHealth;

        List skills = new ArrayList();
        List bonuses = new ArrayList();

        public TankAnalysis() {
            methodType = Method.METHOD_TANK;
        }

        
        protected void populateBonuses() {
            bonuses = bonuses;
        }


        void onAnalysisComplete(List analysis);
}